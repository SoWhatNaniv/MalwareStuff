import ida_ua, idc

start_address = 0x1800041CC
end_address = 0x180005ED1
dynamic_apis = []


def main(start_address, end_address):
    
    print("Starting..")
    
    ea = start_address
    current_insn = ida_ua.insn_t()
    
    temp_value = 0x0
    previous_instr = False
    temp_string = ""
    
    while ea < end_address: 
                
        # Create the instruction from the current address
        ins_len = idc.create_insn(ea)
        
        # Some of the code in .text is nonsense and is not really opcodes so ins_len won't work here
        # So we just add 1 to address until we get back at a valid code chunk
        if ins_len == 0:
            ea += 1
            continue
            
        ida_ua.decode_insn(current_insn, ea)
        
        if current_insn.get_canon_mnem() == "mov" and current_insn.Op2.type == 5 and current_insn.Op2.value < 0x100 and current_insn.Op1.reg == 16:
            temp_value = current_insn.Op2.value
            previous_instr = True
            ea += ins_len
            continue                      
        
        if current_insn.get_canon_mnem() == "mov" and current_insn.Op2.type == 5 and current_insn.Op2.value == 0 and (current_insn.Op1.reg == 7 or current_insn.Op1.reg == 14):
            dynamic_apis.append(temp_string)
            temp_string = ""
         
        if current_insn.get_canon_mnem() == "add" and previous_instr and current_insn.Op2.type == 5 and current_insn.Op2.value < 0x100 and current_insn.Op1.reg == 16:
            temp_value += current_insn.Op2.value  
            idc.set_cmt(ea, chr(temp_value), 0) # Set the char value as a comment  
            temp_string += chr(temp_value)   
              
        ea += ins_len
        temp_value = 0x0
        previous_instr = False
 

main(start_address, end_address)

# Print all of the strings that we've just collected (the strings here are the flow of the code)
print(dynamic_apis)
