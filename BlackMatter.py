import idautils, ida_ua
import os, pefile    
    
 
# ROR Function
def ror(value, bits):
    # Rotate right a 32-bit integer by `bits`
    return ((value >> bits) | (value << (32 - bits))) & 0xFFFFFFFF


# Custom Function Hashing
def calc_function_hash(a1, a2):
    for char in a1 + "\x00":
        # Get the ASCII value of the character
        v2 = ord(char)

        # Rotate a2 right by 13 bits and add the character's value
        a2 = (v2 + ror(a2, 13)) & 0xFFFFFFFF

    return a2
    

# Custom Dll Hashing
def calc_dll_hash(a1, a2):
    for char in a1 + "\x00":
        # Get the ASCII value of the character
        v2 = ord(char)
        
        # Convert uppercase letters to lowercase
        if 0x41 <= v2 <= 0x5A:  # 'A' to 'Z'
            v2 |= 0x20  # Convert to lowercase by setting the 6th bit

        # Rotate a2 right by 13 bits and add the character's value
        a2 = (v2 + ror(a2, 13)) & 0xFFFFFFFF

    return a2
 
 
def get_all_dll_hashes():
    
    dll_files = []
    dll_hashes = {}
    
    # Iterate over all files in the directory
    for file_name in os.listdir("C:\Windows\SysWow64"):
        # Check if the file has a .dll extension (case-insensitive)
        if file_name.lower().endswith(".dll"):
            dll_files.append(file_name)
    
    for dll in dll_files:
        dll_hashes[dll] = calc_dll_hash(dll, 0)
    
    return dll_hashes


def clear_unrelevant_hashes(dll_hashes):

    relevant_hashes = [0x6310285A, 0x93FA208B, 0x9EFC498A, 0x5334FE9A, 0x12341FD7, 0x1B1E6F59, 0x1A342057,
    0x0E70A3882, 0x0A00C474E, 0x0DF1C482B, 0x63EEFFFA, 0x1EFA48DA, 0x0E1BA09EA, 0x54EE26F8]
    
    relevant_hashes = [0x22065FED ^ i for i in relevant_hashes]
    
    r_dll_hashes = {}
    
    for dll_name, dll_hash in dll_hashes.items():
        if dll_hash in relevant_hashes:
            r_dll_hashes[dll_name] = dll_hash
    
    return r_dll_hashes
    
def parse_pe_exported_function_table(file_path):
    
    func_names = []
    
    try:
        pe = pefile.PE(file_path)
        
        # Check if the file has an export directory
        if not hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            return []
        
        # Iterate over exported functions
        for export in pe.DIRECTORY_ENTRY_EXPORT.symbols:
            func_name = export.name.decode('utf-8')
            func_names.append(func_name)
                    
    except Exception as e:
        pass
        
    return func_names


# Retrieve All The API Hashes That Are Being Used In The Code
def get_all_api_hashes():

    func_ea = 0x40581d
    xrefs = idautils.CodeRefsTo(func_ea, 1)
    api_hashes = []

    # Iterate over all of the resolve API hash references
    for ref in xrefs:
        
        # Exception Address
        if ref == 0x405ab5:
            api_hashes.append(0)
            continue

        current_insn = ida_ua.insn_t()
        ea = prev_head(ref)

        val1 = 0x0
        val2 = 0x0

        # Iterate backward through instructions until required values are found
        while True:
            ida_ua.decode_insn(current_insn, ea)

            # Check for mov instruction and if val2 is already found
            if current_insn.get_canon_mnem() == "mov" and val2:
                val1 = current_insn.Op2.value
                break

            # Check for xor instruction to set val2
            elif current_insn.get_canon_mnem() == "xor":
                val2 = current_insn.Op2.value

            ea = prev_head(ea)

        api_hashes.append(val1 ^ val2)

    return api_hashes


def resolve_api_hashes(dll_hashes_dict, api_hashes):
       
    apis = {}   
    
    # Iterate over all files in the directory
    for file_name in os.listdir("C:\Windows\SysWow64"):
    
        # Check if the file has a .dll extension (case-insensitive)
        if not file_name.lower().endswith(".dll"):
            continue
        
        for dll_name, dll_hash in dll_hashes_dict.items():
            if file_name.lower() == dll_name: 
                dll_path = os.path.join(r"C:\Windows\SysWow64", file_name)
                exported_functions = parse_pe_exported_function_table(dll_path)
                
                for exported_function in exported_functions:
                    temp_func_hash = calc_function_hash(exported_function, dll_hash)
                    if temp_func_hash in api_hashes:
                        apis[exported_function] = temp_func_hash
    
    return apis
    


api_hashes = get_all_api_hashes()
dll_hashes = get_all_dll_hashes()
relevant_dll_hashes = clear_unrelevant_hashes(dll_hashes)
mapped_apis = resolve_api_hashes(relevant_dll_hashes, api_hashes)